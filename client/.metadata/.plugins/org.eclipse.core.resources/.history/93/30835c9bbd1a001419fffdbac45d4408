package stock.com.ui.elements.xpainting
{
    import flash.geom.*;

    public class Calculator extends Object
    {
        public static const HORIZONTAL:String = "horizontal";
        public static const RIGHTBUTTOM:String = "rightbuttom";
        public static const LEFTTOP:String = "lefttop";
        private static var _instance:Calculator = null;
        public static const VERTICAL:String = "vertical";
        public static const LEFTBUTTOM:String = "leftbuttom";
        public static const RIGHTTOP:String = "lefttop";

        public function Calculator()
        {
            return;
        }// end function

        public function calcAverage(param1:Array) : Number
        {
            if (!param1)
            {
                return 0;
            }
            var _loc_2:* = param1.length;
            var _loc_3:Number = 0;
            var _loc_4:int = 0;
            while (_loc_4 < _loc_2)
            {
                
                if (isNaN(param1[_loc_4]))
                {
                }
                else
                {
                    _loc_3 = _loc_3 + Number(param1[_loc_4]);
                }
                _loc_4++;
            }
            return _loc_3 / _loc_2;
        }// end function

        private function testConverse(param1:String, param2:String) : Boolean
        {
            if (param2 == VERTICAL && (param1 == LEFTBUTTOM || param1 == RIGHTBUTTOM))
            {
                return true;
            }
            if (param2 == HORIZONTAL && (param1 == RIGHTTOP || param1 == RIGHTBUTTOM))
            {
                return true;
            }
            return false;
        }// end function

        public function calcNormalVector(param1:Point, param2:Number = 1) : Point
        {
            var _loc_3:* = new Point(param1.y, -param1.x);
            return this.getVectorByLength(_loc_3, param2);
        }// end function

        public function calcLinesDirectedDistance(param1:Point, param2:Point, param3:Point) : Number
        {
            if (Math.abs(param3.x) + Math.abs(param3.y) == 0)
            {
                return 0;
            }
            return this.calcDotProduct(new Point(param2.x - param1.x, param2.y - param1.y), param3) / this.calcVectorLength(param3);
        }// end function

        public function calcFibonacciSeries(param1:int, param2:Number, param3:int) : Array
        {
            var _loc_6:int = 0;
            var _loc_4:Array = [];
            [].push(param1);
            _loc_4.push(param2);
            _loc_4.unshift(_loc_4[1] - _loc_4[0]);
            _loc_4.unshift(_loc_4[1] - _loc_4[0]);
            _loc_4.pop();
            _loc_4.pop();
            var _loc_5:int = 2;
            while (true)
            {
                
                _loc_6 = _loc_4[(_loc_5 - 1)] + _loc_4[_loc_5 - 2];
                if (_loc_6 > param3)
                {
                    break;
                }
                else
                {
                    _loc_4.push(_loc_6);
                }
                _loc_5++;
            }
            _loc_4.shift();
            _loc_4.shift();
            return _loc_4;
        }// end function

        public function calcDistance(param1:Point, param2:Point) : Number
        {
            return this.calcVectorLength(new Point(param2.x - param1.x, param2.y - param1.y));
        }// end function

        public function calcPos(param1:Number, param2:Number, param3:Number, param4:Number) : Number
        {
            if (isNaN(param1) || param1 <= param2)
            {
                return (param4 - 1);
            }
            if (param1 >= param3)
            {
                return 1;
            }
            return param4 * (1 - (param1 - param2) / (param3 - param2));
        }// end function

        public function getEndPoints(param1:Point, param2:Point, param3:Rectangle) : Array
        {
            var _loc_4:Number = NaN;
            var _loc_5:Number = NaN;
            var _loc_6:Number = NaN;
            var _loc_7:Number = NaN;
            if (param2.x == 0 && param2.y == 0)
            {
                return [param1, param1];
            }
            if (param2.x != 0)
            {
                _loc_4 = param3.left;
                _loc_5 = (_loc_4 - param1.x) * (param2.y / param2.x) + param1.y;
                _loc_6 = param3.right;
                _loc_7 = (_loc_6 - param1.x) * (param2.y / param2.x) + param1.y;
            }
            else
            {
                _loc_5 = param3.top;
                _loc_4 = (_loc_5 - param1.y) * (param2.x / param2.y) + param1.x;
                _loc_7 = param3.bottom;
                _loc_6 = (_loc_7 - param1.y) * (param2.x / param2.y) + param1.x;
            }
            return [new Point(_loc_4, _loc_5), new Point(_loc_6, _loc_7)];
        }// end function

        public function calcRelativePos(param1:Number, param2:Number, param3:Number) : Number
        {
            if (isNaN(param1) || param1 <= param2)
            {
                return 0;
            }
            if (param1 >= param3)
            {
                return 1;
            }
            return (param1 - param2) / (param3 - param2);
        }// end function

        public function getVectorByLength(param1:Point, param2:Number = 1) : Point
        {
            if (Math.abs(param1.x) + Math.abs(param1.y) <= 0.01)
            {
                return param1;
            }
            var _loc_3:* = new Point(param1.x * param2 / this.calcVectorLength(param1), param1.y * param2 / this.calcVectorLength(param1));
            return _loc_3;
        }// end function

        public function calcRegularRectangle(param1:Rectangle) : Rectangle
        {
            return new Rectangle(Math.min(param1.left, param1.right), Math.min(param1.top, param1.bottom), Math.abs(param1.right - param1.left), Math.abs(param1.bottom - param1.top));
        }// end function

        public function testInRectangle(param1:Point, param2:Rectangle) : Boolean
        {
            return param1.x >= param2.left && param1.x <= param2.right && param1.y >= param2.top && param1.y <= param2.bottom;
        }// end function

        private function calcDotProduct(param1:Point, param2:Point) : Number
        {
            return param1.x * param2.x + param1.y * param2.y;
        }// end function

        public function calcAbsolutePose(param1:Number, param2:Number, param3:String = "leftbuttom", param4:String = "vertical") : Number
        {
            var _loc_5:Number = 0;
            if (param1 <= 0)
            {
                _loc_5 = 1;
            }
            else if (param1 >= 1)
            {
                _loc_5 = param2;
            }
            else
            {
                _loc_5 = param1 * param2;
            }
            if (this.testConverse(param3, param4))
            {
                _loc_5 = param2 - _loc_5;
            }
            return _loc_5;
        }// end function

        private function calcVectorLength(param1:Point) : Number
        {
            return Math.sqrt(param1.x * param1.x + param1.y * param1.y);
        }// end function

        public function calcLinesDistance(param1:Point, param2:Point, param3:Point) : Number
        {
            return Math.abs(this.calcLinesDirectedDistance(param1, param2, param3));
        }// end function

        public static function get instance() : Calculator
        {
            var _loc_1:* = new Calculator;
            _instance = new Calculator;
            return _instance;
        }// end function

    }
}
